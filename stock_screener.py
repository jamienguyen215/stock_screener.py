{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "5d25a9a7",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2023-04-05 13:34:21.011 \n",
      "  \u001b[33m\u001b[1mWarning:\u001b[0m to view this Streamlit app on a browser, run it with the following\n",
      "  command:\n",
      "\n",
      "    streamlit run C:\\Users\\User\\anaconda3\\lib\\site-packages\\ipykernel_launcher.py [ARGUMENTS]\n"
     ]
    }
   ],
   "source": [
    "#stock_screener.py\n",
    "\n",
    "from pandas_datareader import data as pdr\n",
    "from yahoo_fin import stock_info as si\n",
    "# import yahoo_fin\n",
    "#from pandas import ExcelWriter\n",
    "import yfinance as yf\n",
    "import pandas as pd\n",
    "import requests\n",
    "import datetime\n",
    "import time\n",
    "from pprint import pprint\n",
    "from collections import OrderedDict\n",
    "import streamlit as st\n",
    "import base64\n",
    "\n",
    "\n",
    "def period(days=365):\n",
    "  '''\n",
    "  return start and end dates\n",
    "  '''\n",
    "  start_date = datetime.datetime.now() - datetime.timedelta(days=365)\n",
    "  end_date = datetime.date.today()\n",
    "  return start_date, end_date \n",
    "\n",
    "def calc_relative_strength(df):\n",
    "  ## relative gain and losses\n",
    "  df['close_shift'] = df['adj_close'].shift(1)\n",
    "  ## Gains (true) and Losses (False)\n",
    "  df['gains'] = df.apply(lambda x: x['adj_close'] if x['adj_close'] >= x['close_shift'] else 0, axis=1)\n",
    "  df['loss'] = df.apply(lambda x: x['adj_close'] if x['adj_close'] <= x['close_shift'] else 0, axis=1)\n",
    "\n",
    "  avg_gain = df['gains'].mean()\n",
    "  avg_losses = df['loss'].mean()\n",
    "\n",
    "  return avg_gain / avg_losses\n",
    "\n",
    "def get_stock(stock, days=365):\n",
    "    start_date, end_date =period(days)\n",
    "    try: \n",
    "        df = pdr.get_data_yahoo(stock, start=start_date, end=end_date )\n",
    "        df = df.drop(['High', 'Low', 'Open','Close'], axis=1)\n",
    "        df = df.rename(columns={'Adj Close': \"adj_close\"})\n",
    "        \n",
    "    except:\n",
    "        return False\n",
    "    if len(df) < 2:\n",
    "        print('Less 2')\n",
    "        return False\n",
    "    return df\n",
    "    \n",
    "def rs_rating(stock_rs_strange_value, index_rs_strange_value):\n",
    "  # print(f'Stock RS:{stock_rs_strange_value}, Index RS:{index_rs_strange_value}')\n",
    "  return 100 * ( stock_rs_strange_value / index_rs_strange_value )\n",
    "\n",
    "class Moving_avg:\n",
    "  # self.index_strange = index_strange \n",
    "  def __init__(self, stockname, df,  index_strange, min_rs_rating=70):\n",
    "    self.stockname = stockname\n",
    "    self.df = df\n",
    "    \n",
    "    # self.stock_data = get_stock(stockname)\n",
    "\n",
    "    self.df = self.calc_moving_avg(self.df)\n",
    "    self.price = self.df['adj_close'][-1]\n",
    "    self.sma50 = self.df[\"SMA_50\"][-1]\n",
    "    self.sma150 = self.df[\"SMA_150\"][-1]\n",
    "    self.sma200 = self.df[\"SMA_200\"][-1]\n",
    "    self.index_rs_strange = index_strange\n",
    "    self.stock_rs_strange = calc_relative_strength(self.df)\n",
    "    self.rs_rating = rs_rating(self.stock_rs_strange, self.index_rs_strange)\n",
    "    self.min_rs_rating = min_rs_rating\n",
    "    self.low_of_52week = self.df[\"adj_close\"][-260:].min()\n",
    "    self.high_of_52week = self.df[\"adj_close\"][-260:].max()\n",
    "\n",
    "    try:\n",
    "      ## Need to double check this \n",
    "      ## should SMA trending up for at least 1 month (ideally 4-5 months)\n",
    "        self.sma200_20 = df[\"SMA_200\"][-20]\n",
    "    except:\n",
    "        self.sma200_20 = 0\n",
    "\n",
    "  def as_dict(self):\n",
    "    try:\n",
    "        company_name = yf.Ticker(self.stockname).info['longName']\n",
    "    except:\n",
    "        company_name = self.stockname\n",
    "    # return self.__dict__\n",
    "    return OrderedDict([\n",
    "       ('Company Name', company_name),\n",
    "       ('Ticker', self.stockname),\n",
    "       ('Current Price', self.price),\n",
    "       ('RS Rating', self.rs_rating),\n",
    "       ('SMA 50 Day', self.sma50),\n",
    "       ('SMA 150 Day', self.sma150),\n",
    "       ('SMA 200 Day', self.sma200),\n",
    "       ('52 Week Low', self.low_of_52week),\n",
    "       ('52 Week High', self.high_of_52week),\n",
    "       ])\n",
    "\n",
    "  def calc_moving_avg(self, df):\n",
    "    for x in [50,150,200]:\n",
    "      df[\"SMA_\"+str(x)] = round(df['adj_close'].rolling(window=x).mean(), 2)\n",
    "    return df\n",
    "  \n",
    "\n",
    "  def avg_volume(self):\n",
    "    return self.df['volume'].mean()\n",
    "\n",
    "  def condition1(self):\n",
    "    # Condition 1: Current Price > 150 SMA and > 200 SMA\n",
    "    if (self.price > self.sma150 and self.price > self.sma200):\n",
    "      return True\n",
    "\n",
    "  def condition2(self):\n",
    "    # Condition 2: 150 SMA and > 200 SMA\n",
    "    if (self.sma150 > self.sma200):\n",
    "      return True\n",
    "\n",
    "  def condition3(self):\n",
    "    # Condition 3: 200 SMA trending up for at least 1 month (ideally 4-5 months)\n",
    "    if self.sma200 > self.sma200_20:\n",
    "      return True \n",
    "  \n",
    "  def condition4(self):\n",
    "    # Condition 4: 50 SMA> 150 SMA and 50 SMA> 200 SMA\n",
    "    if self.sma50 > self.sma150 > self.sma200:\n",
    "      return True\n",
    "\n",
    "  def condition5(self):\n",
    "    # Condition 5: Current Price > 50 SMA\n",
    "    if self.price > self.sma50:\n",
    "      return True \n",
    "  \n",
    "  def condition6(self):\n",
    "    # Condition 6: Current Price is at least 30% above 52 week low (Many of the best are up 100-300% before coming out of consolidation)\n",
    "    if self.price >= (1.3 * self.low_of_52week):\n",
    "      return True\n",
    "  \n",
    "  def condition7(self):\n",
    "  # Condition 7: Current Price is within 25% of 52 week high\n",
    "    if self.price >= (0.75 * self.high_of_52week):\n",
    "      return True\n",
    "  \n",
    "  def condition8(self):\n",
    "  # Condiction 8: IBD RS_Rating greater than 70\n",
    "    if self.rs_rating >=self.min_rs_rating:\n",
    "      return True\n",
    "\n",
    "  def all_conditions(self):\n",
    "    if all(\n",
    "        [self.condition1(),\n",
    "          self.condition2(),\n",
    "          self.condition3(),\n",
    "          self.condition4(),\n",
    "          self.condition5(),\n",
    "          self.condition6(),\n",
    "          self.condition7(),\n",
    "          self.condition8()]):\n",
    "    \treturn True\n",
    "\n",
    "def filedownload(df):\n",
    "    csv = df.to_csv(index=False)\n",
    "    b64 = base64.b64encode(csv.encode()).decode()  # strings <-> bytes conversions\n",
    "    href = f'<a href=\"data:file/csv;base64,{b64}\" download=\"MM_stock_screener.csv\">Download CSV File</a>'\n",
    "    return href    \n",
    "\n",
    "def stock_screener(index_tinker_name='S&P500', min_vol=5e6, min_price=0, days=365, min_rs_rating=70,):\n",
    "# help(si)\n",
    "    ## fix for yahoo_fin\n",
    "    start_date, end_date = period(days)\n",
    "    yf.pdr_override()\n",
    "\n",
    "    index_tinker = {\n",
    "        'DOW': 'DOW',\n",
    "        'NASDAQ': '^IXIC', \n",
    "        \"S&P500\": '^GSPC'}\n",
    "\n",
    "    index_list = {\n",
    "        'DOW': si.tickers_sp500(),\n",
    "        'NASDAQ': si.tickers_nasdaq(),\n",
    "        \"S&P500\": si.tickers_sp500()}\n",
    "    \n",
    "    st.header(f'Stock Screener {index_tinker_name}')\n",
    "    # stocklist = si.tickers_sp500()\n",
    "    min_volume = min_vol\n",
    "    # index_name = '^GSPC' # SPY or S&P 500\n",
    "    stocklist = index_list.get(index_tinker_name)[:]\n",
    "    \n",
    "    index_rs_strange_value = calc_relative_strength(\n",
    "                                 get_stock(\n",
    "                                    index_tinker[index_tinker_name], days)\n",
    "                                 )\n",
    "\n",
    "    final = []\n",
    "    index = []\n",
    "    \n",
    "    exclude_list = []\n",
    "    all_data = []\n",
    "    latest_iteration = st.empty()\n",
    "    having_break = st.empty()\n",
    "    bar = st.progress(0)\n",
    "    total = len(stocklist)\n",
    "    \n",
    "    for num, stock_name in enumerate(stocklist):\n",
    "        print(f\"checking {num}:{stock_name}\")\n",
    "        if stock_name in exclude_list:\n",
    "            continue\n",
    "            FAILED = False\n",
    "        df = get_stock(stock_name)\n",
    "        # print('**',df)\n",
    "        if df is False:\n",
    "            print(f'SKIPPED to download {stock_name} {num}')\n",
    "            continue\n",
    "\n",
    "        stock_meta = Moving_avg(stock_name, df, index_rs_strange_value, min_rs_rating)\n",
    "        time.sleep(0.2)\n",
    "        \n",
    "        if stock_meta.all_conditions():\n",
    "            print(f'Passed conditions: {stock_name}')\n",
    "            final.append(stock_meta.as_dict())\n",
    "        else:\n",
    "            print(f'Failed conditions: {stock_name}')  \n",
    "            # all_data.append(stock_meta.as_dict())\n",
    "            \n",
    "        latest_iteration.text(f'Stocks Processed: {(num+1)}/{total}')\n",
    "        bar.progress((num+1)/total)\n",
    "        \n",
    "\n",
    "        if num == 0:\n",
    "            continue\n",
    "        if num % 10 == 0:\n",
    "            for i in list(range(5))[::-1]:\n",
    "                having_break.text(f'waiting for {i}sec')\n",
    "                time.sleep(1)\n",
    "            # having_break = st.empty()\n",
    "        if num % 100 == 0:\n",
    "            for i in list(range(3))[::-1]:\n",
    "                having_break.text(f'waiting for {i}min')\n",
    "                time.sleep(60)\n",
    "            # having_break = st.empty()\n",
    "            # time.sleep(5*60)\n",
    "\n",
    "    final_df = pd.DataFrame(final)\n",
    "    # all_data_df = pd.DataFrame(all_data)\n",
    "    return final_df \n",
    "\n",
    "\n",
    "#### ---- The App ---- ####\n",
    "## ref: https://towardsdatascience.com/making-a-stock-screener-with-python-4f591b198261\n",
    "st.sidebar.header('Settings')\n",
    "index_tinker = st.sidebar.selectbox('Index', ['S&P500', 'DOW', 'NASDAQ', ] )\n",
    "min_volume = st.sidebar.text_input(\"Minimum Volume\", 1e6)\n",
    "min_price = st.sidebar.slider('Minimum Price ($)', 0,5000, 0)\n",
    "days = st.sidebar.slider('Max Period (days)', 14, 730, 365)\n",
    "min_rs_rating = st.sidebar.slider('Minimum Relative Strange Rating', 1, 100, 70)\n",
    "with st.container():\n",
    "    st.title('Mark Minervini’s Trend stock screener')\n",
    "    st.write('''\n",
    "        I've created this app help screen for stock using the Mark Minervini's 8 principles\n",
    "        inspried by these blogs:\n",
    "        * [How To Scan Mark Minervini’s Trend Template Using Python](https://www.marcellagerwerf.com/how-to-scan-mark-minervinis-trend-template-using-python/)\n",
    "        * [How to build a stock screener](https://www.youtube.com/watch?v=hngHA9Jjbjc&list=PLPfme2mwsQ1FQhH1icKEfiYdLSUHE-Wo5&index=3&ab_channel=RichardMoglen)\n",
    "        * [Making a Stock Screener with Python!](https://towardsdatascience.com/making-a-stock-screener-with-python-4f591b198261)\n",
    "\n",
    "        You can read more about this template in Mark Minervini’s [blog post](http://www.minervini.com/blog/index.php/blog/first_things_first_how_to_chart_stocks_correctly_and_increase_your_chances).\n",
    "        ''')\n",
    "    expander = st.expander(\"Principles\")\n",
    "\n",
    "    expander.write('''\n",
    "\n",
    "        1. The current price of the security must be greater than the 150 and 200-day simple moving averages.\n",
    "        2. The 150-day simple moving average must be greater than the 200-day simple moving average.\n",
    "        3. The 200-day simple moving average must be trending up for at least 1 month.\n",
    "        4. The 50-day simple moving average must be greater than the 150 simple moving average and the 200 simple moving average.\n",
    "        5. The current price must be greater than the 50-day simple moving average.\n",
    "        6. The current price must be at least 30% above the 52 week low.\n",
    "        7. The current price must be within 25% of the 52 week high.\n",
    "        8. The IBD RS-Rating must be greater than 70 (the higher, the better). The RS rating is a metric of a stock’s price performance over the last year compared to all other stocks and the overall market. Check out this article to learn more.\n",
    "        \n",
    "        ''')\n",
    "    # I created this article to help others make an easy-to-read stock screener Python program based on Mark Minervini’s Trend Template (the 8 principles on selecting the best stocks\n",
    "\n",
    "\n",
    "    if st.button('Start screening'):\n",
    "        # st.header('Socker screener')\n",
    "        \n",
    "        final_df = stock_screener(index_tinker, min_volume, min_price, days, min_rs_rating)\n",
    "        st.dataframe(final_df)\n",
    "        \n",
    "        st.markdown(filedownload(final_df), unsafe_allow_html=True)\n",
    "        st.set_option('deprecation.showPyplotGlobalUse', False)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bbbf86fc",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dcf107ea",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
